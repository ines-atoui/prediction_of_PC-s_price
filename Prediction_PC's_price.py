# -*- coding: utf-8 -*-
"""My project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u-2jgQN4b2xgX6N07HRGLM5ZyWtVwDmc
"""

pip install streamlit

"""#1.  Import libraries








"""

import pandas as pd
import re
from sklearn import preprocessing
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import normalize
from yellowbrick.cluster import KElbowVisualizer
import scipy.cluster.hierarchy as shc
from sklearn.cluster import KMeans
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn import metrics
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn import tree
import streamlit as st

"""#2. Loading our dataset"""

pc=pd.read_csv("mytek.csv")
pc

"""#3. Exploration and cleaning our data

##*getting a quick overview of our data*
"""

pc.head()

pc.info()

pc.describe()

"""##Identifying and handling missing values"""

#Checking for missing values
pc.isnull().sum()

#dropping the unnecessary columns
pc=pc.drop(columns=['web-scraper-order','dispo','processeur','web-scraper-start-url','connectors','gtin','couleur'	,'select'	,'select-href',	'pagination'	,'prod',	'prod-href','gamme','systeme','taille_ecran'], axis=1)

#dropping missing values (columns with NaN)
pc=pc.dropna()

pc.isnull().sum()

"""##Some visualization"""

pc['prix'].value_counts()

#dropping string of form "-?\d+DT"
prix=[]
for price in pc['prix']:
    clean_text = re.sub(r'-?\d+DT', '', price)
    prix.append(clean_text)
prix

#dropping string 'Prix spécial|Ancien prix|\xa0|DT|\u202f'
prixx=[]
for price in prix:
    clean_text = re.sub(r'Prix spécial|Ancien prix|\xa0|DT|\u202f', '', price)
    prixx.append(clean_text)
prixx

#splitting column and selecting the first element
l1=[]
parts=[]
for line in prixx:

    parts = line.split('  ')
    l1.append(parts[0])
pc['prix']=l1
pc['prix']

#replace "," by "." in the column prix
x=[]
for i in pc["prix"]:
  x.append(i.replace(",", "."))
pc['prix']=x

#convert the type of "prix" into float
pc['prix']=pc['prix'].astype("float")

#Price Distribution by Brand
sns.barplot(x=pc['marque'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix par marque')
plt.show()

#Price Distribution by type of processeur
sns.barplot(x=pc['type_processeur'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix par type de processeur')
plt.show()

sns.barplot(x=pc['ram'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix par capacité du RAM')
plt.show()

#Price Distribution by type of hard drive
sns.barplot(x=pc['type_disk'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix par type de disque dur')
plt.show()

#Distribution of Prices Based on Warranty
sns.barplot(x=pc['grantie'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix selon la garantie')
plt.show()

#Distribution of Prices Based on memoire cache
sns.barplot(x=pc['memoire_cache'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix selon la memoire cache')
plt.show()

#price with pc gamer or not
sns.barplot(x=pc['gamer'], y=pc['prix'])
plt.xticks(rotation='vertical')
plt.title('Distribution des prix selon la caracteristique Gamer')
plt.show()

"""##Formatting and transforming data"""

#determining potential values of each column
pc.nunique()

#converting the "grantie" and "gamer" variable into numerical data
pc['gamer']=pc['gamer'].map({"oui": 1 , "Non": 0})
pc['grantie']=pc['grantie'].map({"1 an": 1 , "2 ans": 2 ,"3 ans":3 })
pc

pc['memoire_cache'].value_counts()

pc['ram'].value_counts()

#extracting the numeric part of the two columns (memoire_cache and ram)
pc['memoire_cache']=pc['memoire_cache'].str[:-2]
pc['ram']=pc['ram'].str[:-2]

#converting the type of the data into "int"
pc['memoire_cache']=pc['memoire_cache'].astype("int")
pc['ram']=pc['ram'].astype("int")

pc

pc['disque_dur'].value_counts()

#transfering disque_dur's data from "To" to "Go"

pc1=[]
for p in pc['disque_dur']:
   pc1.append( p.replace("1 To ", "1024 Go "))

pc2=[]
for p in pc1:
    pc2.append( p.replace("1To ", "1024 Go "))

pc3=[]
for p in pc2:
    pc3.append( p.replace("2To ", "2048 Go "))

pc['disque_dur']=pc3

pc['disque_dur'].value_counts()

#converting the variable into numerical data

label_encoder_disque_dur= preprocessing.LabelEncoder()
label_encoder_marque = preprocessing.LabelEncoder()
label_encoder_type_processeur = preprocessing.LabelEncoder()
label_encoder_type_disk = preprocessing.LabelEncoder()
label_encoder_carte_graphic = preprocessing.LabelEncoder()
label_encoder_chipset_carte = preprocessing.LabelEncoder()


pc['disque_dur']= label_encoder_disque_dur.fit_transform(pc['disque_dur'])
pc['marque']= label_encoder_marque.fit_transform(pc['marque'])
pc['type_processeur']= label_encoder_type_processeur.fit_transform(pc['type_processeur'])
pc['type_disk']= label_encoder_type_disk.fit_transform(pc['type_disk'])
pc['carte_graphic']= label_encoder_carte_graphic.fit_transform(pc['carte_graphic'])
pc['chipset_carte']= label_encoder_chipset_carte.fit_transform(pc['chipset_carte'])

pc['resolution'].value_counts()

#extracting only the numeric part of the data
pc['resolution']=pc['resolution'].str[:-7]
pc['resolution']

#create two columns for the screen's "width" and "height"
pc['screen_width']=pc['resolution'].str.split("x").apply(lambda x : x[0])
pc['screen_height']=pc['resolution'].str.split("x").apply(lambda x : x[1])
pc['screen_height'].value_counts()

#converting the type of the data into "int"
pc['screen_width']=pc['screen_width'].astype("int")
pc['screen_height']=pc['screen_height'].astype("int")

#dropping "resolution" column
pc=pc.drop(columns=['resolution'],axis=1)

#extracting string of form "i\d+"

cleaned=[]
for i in pc['ref_proc']:
  clean_text = re.sub(r'[®|™|\xa0|\u200b]', '', i)
  cleaned.append(clean_text)
pc['ref_proc']=cleaned

pc['ref_proc'].unique()

#converting the variable into numerical data

label_encoder_ref_proc=preprocessing.LabelEncoder()
pc['ref_proc']= label_encoder_ref_proc.fit_transform(pc['ref_proc'])

# pc.to_csv('data.csv',sep=';' ,index=False, encoding="utf-8")

pc['freq_processeur'].value_counts()

#select the max of processor's frequency
l=[]
l1=[]
for i in pc['freq_processeur']:
  substrings = i.split(' to')
  l.append(substrings)
for i in l:
  j= l.index(i)
  l1.append(l[j][1])

l1

#select only the numbers
l2=[]
for i in l1:
  numbers = re.findall(r'\d\.\d+|\d\,\d+', i)
  l2.append(numbers)
print(type(l2))

#create a column containing the "max" of freq_processeur
pc['freq_processeur_max']= sum(l2, [])

#convert ',' to '.'
x=[]
for i in pc['freq_processeur_max'] :
  x.append(i.replace(",", "."))
pc['freq_processeur_max']=x

#converting the type of the data into "float"
pc['freq_processeur_max']=pc['freq_processeur_max'].astype("float")

#droppind freq_processeur column
pc = pc.drop('freq_processeur', axis=1)

pc.info()

pc

#correlation between features
plt.figure(figsize=(18,15))
sns.heatmap(pc.corr(), annot=True , cmap="YlGnBu")

"""#4. Modelling

##Linear Regression
"""

#splitting our data
X=pc.drop(columns=["prix"])
y=pc["prix"].values[:,np.newaxis]
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.20,random_state=19)

#fitting our model
model=LinearRegression()
model.fit(X_train,y_train)

#make prediction
predicted=model.predict(X_test)

#calculate metrics
print("MSE", mean_squared_error(y_test,predicted))
print("R squared", metrics.r2_score(y_test,predicted))

"""##2 KNN"""

#fitting our model
knn=KNeighborsClassifier(n_neighbors=15)
knn.fit(X_train,y_train)

#make predictions
y_pred_knn=knn.predict(X_test)

#calculate metrics
print('Acuuracy=',accuracy_score(y_pred_knn,y_test))
print('precision_score=',metrics.precision_score(y_pred_knn,y_test, average='weighted'))
print('recall_score=',metrics.recall_score(y_pred_knn,y_test, average='weighted'))
print('f1_score=',metrics.f1_score(y_pred_knn,y_test, average='weighted'))
print('confusion_matrix=',metrics.confusion_matrix(y_pred_knn,y_test))

# from sklearn.metrics import confusion_matrix
# cm = confusion_matrix(y_test, y_pred_knn)
# confusion_df = pd.DataFrame(cm, index=['Actual'], columns=['Predicted'])
# sns.heatmap(confusion_df, annot=True, cmap='Blues')
# plt.title('Confusion Matrix')
# plt.show()

#The optimal number of neighbors
error_rate = []
for i in range(1,20):
 knn = KNeighborsClassifier(n_neighbors=i)
 knn.fit(X_train,y_train)
 pred_i = knn.predict(X_test)
 error_rate.append(np.mean(pred_i != y_test))
plt.plot(error_rate)

"""##Decision tree"""

#fitting our model
decision_tree = DecisionTreeClassifier(criterion="gini",random_state=19)
decision_tree.fit(X_train, y_train)

#make prediction
y_pred_dt=decision_tree.predict(X_test)

#calculate metrics
print("gini_accuracy={}".format(accuracy_score(y_test, y_pred_dt)))
print('precision_score=',metrics.precision_score(y_pred_dt,y_test, average='weighted'))
print('recall_score=',metrics.recall_score(y_pred_dt,y_test, average='weighted'))
print('f1_score=',metrics.f1_score(y_pred_dt,y_test, average='weighted'))
print('confusion_matrix=',metrics.confusion_matrix(y_pred_dt,y_test))

"""##Random F"""

#fitting our model
RF=RandomForestClassifier(n_estimators=200,random_state=19)
RF.fit(X_train, y_train)

#make prediction
y_pred_rf=RF.predict(X_test)

#calculate metrics
print("Accuracy:", metrics.accuracy_score(y_test, y_pred_rf))
print('precision_score=',metrics.precision_score(y_pred_rf,y_test, average='weighted'))
print('recall_score=',metrics.recall_score(y_pred_rf,y_test, average='weighted'))
print('f1_score=',metrics.f1_score(y_pred_rf,y_test, average='weighted'))
print('confusion_matrix=',metrics.confusion_matrix(y_pred_rf,y_test))
print("MSE", mean_squared_error(y_test,y_pred_rf))
print("R squared", metrics.r2_score(y_test,y_pred_rf))

"""##Improving our models"""

y_test_min=[]
y_test_max=[]
for i in y_test :
  y_test_min.append(i-50)
  y_test_max.append(i+50)

#linear regression
l=[]
for i in range(len(predicted)):
  if y_test_max[i] >= predicted[i] and y_test_min[i] <= predicted[i] :
    l.append(True)
  else:
    l.append(False)
my_series = pd.Series(l)
value_counts = my_series.value_counts()
Acc_lr=(value_counts[0] / len(l) )
print("the accuracy of KNN model =" , Acc_lr)

#KNN model
l=[]
for i in range(len(y_pred_knn)):
  if y_test_max[i] >= y_pred_knn[i] and y_test_min[i] <= y_pred_knn[i] :
    l.append(True)
  else:
    l.append(False)
my_series = pd.Series(l)
value_counts = my_series.value_counts()
Acc_knn=(value_counts[0] / len(l) )
print("the accuracy of KNN model =" , Acc_knn)

#Decision Tree model
l=[]
for i in range(len(y_pred_dt)):
  if y_test_max[i] >= y_pred_dt[i] and y_test_min[i] <= y_pred_dt[i] :
    l.append(True)
  else:
    l.append(False)
my_series = pd.Series(l)
value_counts = my_series.value_counts()
Acc_dt=(value_counts[0] / len(l) )
print("the accuracy of decision tree model =" , Acc_dt)

#Random forest model
l=[]
for i in range(len(predicted)):
  if y_test_max[i] >= y_pred_rf[i] and y_test_min[i] <= y_pred_rf[i] :
    l.append(True)
  else:
    l.append(False)
my_series = pd.Series(l)
value_counts = my_series.value_counts()
Acc_rf=(value_counts[0] / len(l) )
print("the accuracy of random forest model =" , Acc_rf)

data = { 'LR': Acc_lr,'knn':Acc_knn, 'decision_tree':Acc_dt,
        'RF':Acc_rf}
models_name  = list(data.keys())
accuracy = list(data.values())

fig = plt.figure(figsize = (10, 5))

plt.bar(models_name, accuracy, color ='green',
        width = 0.4)

plt.xlabel("models_name")
plt.ylabel("accuracy")
plt.title("a summary graph which resume all accuracies of each model")
plt.show()

"""#5. Streamlit app"""

chipset_intel=['Intel UHD','Intel Iris X','Intel HD']
chipset_nvidea=['GeForce MX330','GeForce RTX 3050','GeForce MX450','GeForce MX350','GeForce MX550','GeForce GTX 1650','GeForce RTX 3060','GeForce RTX 3050Ti','GeForce RTX 2050','GeForce RTX 4050','GeForce RTX 4060','GeForce RTX 4070','GeForce RTX 3070TI','GeForce RTX 3080 Ti','GeForce RTX 3070','GeForce GTX 1660Ti']
chipset_Amd=['AMD Radeon','AMD Radeon RX 6600 M','AMD Radeon RX 6500M','AMD Radeon Vega 7','AMD Radeon RX 6850M XT']
intelPros=['Intel Celeron N3350', 'Intel Celeron N4120', 'Intel Core i3-1005G1', 'Intel Core i3-10110U', 'Intel Core i3-1115G4', 'Intel Core i3-1215U', 'Intel Core i5-10210U', 'Intel Core i5-1035G1', 'Intel Core i5-1135G7', 'Intel Core i5-11400H', 'Intel Core i5-1145G7', 'Intel Core i5-1155G7', 'Intel Core i5-11260H', 'Intel Core i5-11300H', 'Intel Core i5-11320H', 'Intel Core i5-12450H', 'Intel Core i5-12500H', 'Intel Core i7-10510U', 'Intel Core i7-1065G7', 'Intel Core i7-10750H', 'Intel Core i7-10870H', 'Intel Core i7-1165G7', 'Intel Core i7-11800H', 'Intel Core i7-1185G7', 'Intel Core i7-1255U', 'Intel Core i7-1260P', 'Intel Core i7-1265U', 'Intel Core i7-12700H', 'Intel Core i7-13700H', 'Intel Core i7-13700HX', 'Intel Core i9-11900H', 'Intel Core i9-12900H', 'Intel Core i9-13950HX']
amdPros=['AMD 3020e', 'AMD Athlon Silver 3050U', 'AMD Ryzen 3 3250U', 'AMD Ryzen 5 4600H', 'AMD Ryzen 5 5500U', 'AMD Ryzen 5 5600H', 'AMD Ryzen 5 5625U', 'AMD Ryzen 5 6600H', 'AMD Ryzen 7 4800H', 'AMD Ryzen 7 5700U', 'AMD Ryzen 7 5800H', 'AMD Ryzen 7 5800HS', 'AMD Ryzen 7 6800H', 'AMD Ryzen 7 6800HS', 'AMD Ryzen 9 6900HX']

resoo=['1920 x 1080', '1366 x 768', '2880 x 1620', '1920 x 1200', '2160 x 1440', '2560 x 1600', '2880 x 1800', '2560 x 1440','1920 x 1280', '3840 x 2400']

#Building our application

#title of app
st.title("prédiction du prix d'un PC")

#brand of pc
Marque=st.selectbox('Marque',['LENOVO','HP','ASUS','DELL','MSI','ACER','HUAWEI','GIGABYTE'])

#memoire_cache
mm_cache=st.selectbox('Memoire cache (en Mo) ',['2','4','6','8','10','12','16','18','24','30','36'])

#frq_proc
frq_proc=st.selectbox('Fréquence du processeur maximale',['4.20','4.70','4.10','4.40','4.50','3.40','3.90','4.60','3.60','5.00','4.90','4.80','4.00','5.50'])




#ram
ram=st.selectbox('RAM(en Go)',['4','8','12','16','20','24','32','40'])

#type proc
tproc=st.selectbox('Nombre des Coeurs', ['Quad Core','Dual Core','Hexa Core','Octa Core','Dix Core','10 cœurs','12 cœurs','14 Cœurs','16 Cœurs','24 Coeurs'])



#tdisq
tdisq=st.selectbox('Type du disque dur',['SSD','HDD','SSD + HDD','SSHD','eMMC'])
if(tdisq=='SSD'):
   disq=st.selectbox('Stockage de Disque dur', ['256 Go SSD','512Go SSD','1024 Go SSD','2048 Go SSD'])
elif(tdisq=='HDD'):
   disq=st.selectbox('Stockage de Disque dur', ['512 Go','1024 Go HDD'])
elif(tdisq=='SSD + HDD'):
   disq=st.selectbox('Stockage de Disque dur', ['1024 Go + 128Go SSD','1024 Go + 256Go SSD','1024 Go + 500Go SSD','1024 Go + 512Go SSD'])
elif(tdisq=='SSHD'):
   disq=st.selectbox('Stockage de Disque dur', ['512Go SSD'])
else:
   disq=st.selectbox('Stockage de Disque dur', ['64 Go eMMC'])


#carte_graph
carte_graph=st.selectbox('Carte graphique',['Graphique Intégrée','Nvidia GeForce','AMD Radeon'])

if(carte_graph=='Graphique Intégrée'):
   cicaGraphique=st.selectbox('Chipset carte Graphique Intel',chipset_intel)
elif(carte_graph=='Nvidia GeForce'):
   cicaGraphique=st.selectbox('Chipset carte Graphique Nvidea',chipset_nvidea)
else:
   cicaGraphique=st.selectbox('Chipset carte Graphique AMD',chipset_Amd)


#ref_proc
type_pros=st.selectbox('Type du processeur',['Intel Core','AMD'])
if(type_pros=='AMD'):
   ref_pros=st.selectbox('Référence du processeur',amdPros)
else:
   ref_pros=st.selectbox('Référence du processeur',intelPros)


#resolution
display=st.selectbox("Dimension de l'écran", resoo)
width, height = display.split(' x ')


#pc_type(gamer or not)
Gamer=st.selectbox('Gamer',['Oui','Non'])
if (Gamer == 'Oui'):
  gamer=1
else :
  gamer=0

#garantie
gar=st.selectbox('Garantie', ['1 an','2 ans','3ans'])
if(gar=='1 an'):
  garantiee=1
elif(gar=='2 ans'):
  garantiee=2
else:
  garantiee=3


# Label encoder of the selected item

disq_dur=label_encoder_disque_dur.transform([disq])
marque=label_encoder_marque.transform([Marque])
type_proc=label_encoder_type_processeur.transform([tproc])
type_disk=label_encoder_type_disk.transform([tdisq])
carte_graphique=label_encoder_carte_graphic.transform([carte_graph])
cipset_CG=label_encoder_chipset_carte.transform([cicaGraphique])
ref_pross=label_encoder_ref_proc.transform([ref_pros])


disq_dur=disq_dur[0]
marque=marque[0]
type_proc=type_proc[0]
type_disk=type_disk[0]
carte_graphique=carte_graphique[0]
cipset_CG=cipset_CG[0]
ref_pross=ref_pross[0]




# build list of feature


data = {
    'marque': [marque],
    'gamer': [gamer],
    'type_processeur': [type_proc],
    'ref_proc': [ref_pross],
    'memoire_cache': [mm_cache],
    'ram': [ram],
    'disque_dur': [disq_dur],
    'type_disk': [type_disk],
    'carte_graphic': [carte_graphique],
    'chipset_carte': [cipset_CG],
    'grantie': [garantiee],
    'screen_width': [width],
    'screen_height': [height],
    'freq_processeur_max': [frq_proc]
}

df = pd.DataFrame(data)


if st.button('prédiction du prix') :
      y_pr=model.predict(df)
      st.markdown("Le prix du pc est " + str(y_pr[0]) +  "  DT")




# Create a sidebar
st.sidebar.title("Go my code's project graduation")

# Add creator signature
st.sidebar.text("Created by Ines Atoui. \n (AkRoUb).")